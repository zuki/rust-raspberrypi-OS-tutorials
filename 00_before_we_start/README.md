# 始める前に

以下の文章は各チュートリアルにあるカーネルのメインソースコードの冒頭にある文章をそのままコピーしたものです。これはソースコードの全般的な構造を記述し、それぞれのアプローチの背後にある哲学を伝えようとしています。チュートリアルの内容に慣れていただくために、ぜひお読みください。これを読めば、コードを理解しやすくなり、各チュートリアルの違いや追加事項を理解するのに役立ちます。

なお、以下の文章では、チュートリアルの最初の部分ではまだ存在しないソースコードファイル（例：`**/memory.rs`）や関数を参照しています。これらは、チュートリアルが進むにつれて、徐々に追加されていきます。

楽しんでください。

# コードの構成とアーキテクチャ

コードは複数のモジュールに分割されており、それぞれが`カーネル`の代表的な**サブシステム**を表しています。サブシステムのトップレベルのモジュールファイルは `src` フォルダ直下に格納されています。たとえば、`src/memory.rs`には、メモリ管理全般に関するコードが含まれています。

## プロセッサアーキテクチャコードの可視化

カーネルの`サブシステム`の中には、対象となるプロセッサアーキテクチャ固有の低レベルコードに依存するものがあります。それらはサポートされているプロセッサアーキテクチャごとに`src/_arch`配下にサブフォルダが存在します（たとえば、`src/_arch/aarch64`）。

アーキテクチャのフォルダは`src`配下のサブシステムモジュールのレイアウトを踏襲しています。たとえば、`カーネル`のMMUサブシステム（`src/memory/mmu.rs`）に関するアーキテクチャコードは`src/_arch/aarch64/memory/mmu.rs`にあります。後者のファイルは、`path属性`を使って`src/memory/mmu.rs`のモジュールとして読み込まれます。通常、選択されるモジュールの名前は汎用モジュールの名前の先頭に`arch_`を付けたものになります。

たとえば、`src/memory/mmu.rs`の冒頭は次のようになっています。

```
#[cfg(target_arch = "aarch64")]
#[path = "../_arch/aarch64/memory/mmu.rs"]
mod arch_mmu;
```

多くの場合、`arch_ モジュール`のアイテムは親モジュールによりpublicに再エクスポートされます。このようにして、各アーキテクチャ固有のモジュールはアイテムの実装を提供することができ、呼び出し側はどのアーキテクチャが条件付きでコンパイルされているかを気にする必要がありません。

## BSPコード

`BSP`はBoard Support Packageの略です。`BSP`のコードは`src/bsp.rs`としてまとめられており、ターゲットボード固有の定義や機能が含まれています。これには、ボードのメモリマップや、各ボードに搭載されているデバイス用のドライバのインスタンスなどがあります。

プロセッサアーキテクチャのコードと同様に、`BSP`のコードモジュール構造は`カーネル`のサブシステムモジュールを踏襲していますが再エクスポートはしていません。つまり、`bsp::driver::driver_manager()`のように、提供されているものを呼び出す際にはすべて`bsp`名前空間を付ける必要があります。


## カーネルインタフェース

`arch`も`bsp`も、実際にカーネルがコンパイルされるターゲットやボードに応じて条件コンパイルされるコードを含んでいます。たとえば、`Raspberry Pi 3`と`Raspberry Pi 4`では、`割り込みコントローラ`のハードウェアが異なりますが、`カーネル`コードは、2つのうちのどちらともうまく動作するようにしたいものです。

`arch`と`bsp`そして`汎用カーネルコード`の間でクリーンな抽象化を行うために、*可能な限り*、*意味のある*ところには`interface`トレイトが提供されています。これらは各サブシステムモジュールで定義されており、*実装ではなくインターフェイスに対してプログラムする*というイディオムを強制します。たとえば、Raspberryの2つの異なる割り込みコントローラ`ドライバ`が実装するべき共通のIRQ処理インターフェイスを提供し、カーネルの他の部分にはそのインターフェイスだけをエクスポートしています。

```
        +-------------------+
        | インタフェース    |
        |    (トレイト)     |
        +--+-------------+--+
           ^             ^
           |             |
           |             |
+----------+--+       +--+----------+
| カーネル    |       |  bspコード  |
|   コード    |       |  archコード |
+-------------+       +-------------+
```

# まとめ

論理的な`カーネル`サブシステムは、対応するコードを複数の物理的な場所に分散配置できます。ここでは**メモリ**サブシステムの例を示します。

- `src/memory.rs` と `src/memory/**/*`
  - 対象となるプロセッサのアーキテクチャや`BSP`の特性に左右されない共通のコード
    - 例: メモリチャンクをゼロにする関数
  - `arch`や`BSP`のコードで実装されるメモリサブシステムのインタフェース
    - 例: `MMU`関数プロトタイプを定義する`MMU`インタフェース
- `src/bsp/__board_name__/memory.rs` と `src/bsp/__board_name__/memory/**/*`
  - `BSP`特有のコード。
    - 例: ボードのメモリマップ（DRAMやMMIOデバイスの物理アドレス）
- `src/_arch/__arch_name__/memory.rs` と `src/_arch/__arch_name__/memory/**/*`
  - プロセッサアーキテクチャ固有のコード
    - 例: `__arch_name__`プロセッサアーキテクチャ用の`MMU`インタフェースの実装

名前空間の観点から見ると、**メモリ**サブシステムのコードは以下になります。

- `crate::memory::*`
- `crate::bsp::memory::*`


# ブートフロー

1. カーネルのエントリポイントは関数 `cpu::boot::arch_boot::_start()` です。
    - 実装は `src/_arch/__arch_name__/cpu/boot.s` にあります。
